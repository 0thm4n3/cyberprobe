<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<title>cyberprobe - Quick Start</title>

<style type="text/css" media="all">
@import "cyberprobe.css";
</style>

</head>
<body>
<h1>Cyberprobe - Quick Start</h1>

<h2>Table of contents</h2>

<ul>
<li><a href="index.html">Overview</a></li>
<li><a href="quickstart.html">Quick Start tutorial</a></li>
<li><a href="config.html">Configuration</a></li>
<li><a href="output.html">Output streaming protocols</a></li>
<li><a href="management.html">Management interface</a></li>
<li><a href="cybermon.html">Cybermon</a></li>
<li><a href="licence.html">Licence</a></li>
</ul>

<p>This page covers how to get started with minimal reading of stuff.
To run through this tutorial, you will need to run some code with elevated
privileges than a normal 'user' has.  The easiest way to get through this
tutorial is to run the appropriate components as the 'root' user a.k.a. Super
User.
</p>

<h2>Step 1: Build software</h2>

<p>There's a fair amount of development taking place in the git repository,
so you probably want to get the  latest release on the 
<a href="http://sourceforge.net/projects/cyberprobe/files/">downloads</a>
page.
</p>

<p>
But if you do want to track the latest code, checkout the latest code from git:
</p>
<pre>
git clone http://git.code.sf.net/p/cyberprobe/code cyberprobe
</pre>

<p>The code doesn't have many dependencies.  Exotic dependencies are:</p>
<ul>
<li>Boost regex.</li>
<li>Boost shared pointer.</li>
<li>LUA - probably 5.1 or later.</li>
<li>GCC C++ compiler and development support.</li>
<li>PCAP.</li>
<li>Expat (XML parser).</li>
<li>tcpdump - not needed to build the software, but we use it in this
tutorial.</li>
<li>telnet - not needed to build the software, but we use it in this tutorial.
</li>
</ul>

<p>
Note: on many platforms, installing a package just adds the "run time" part
of the code.  In order to be able to compile code against the run time, you
need to install a separate "developers kit" package.  On Fedora, for
instance, both <code>libpcap</code> and <code>libpcap-devel</code> are
needed in order to be able to build this code.
</p>

<p>Unpack the code, and then run <code>make</code>.  This compiles
the following executables:
</p>

<table>
<tr><td><code>cyberprobe</code></td><td>The Cyber Probe executable.</td></tr>
<tr><td><code>cybermon</code></td><td>Data analyser, analyses the data streams and reports events.</td></tr>
<tr><td><code>etsi_rcvr</code></td><td>Test decoder for ETSI format data.</td></tr>
<tr><td><code>nhis11_rcvr</code></td><td>Test decoder for NHIS1.1 format data.</td></tr>
</table>

<p>There isn't anything in the code to manage installation or packaging
yes, but for the purposes of this tutorial, you can run everything from
the directory where you have just built it.</p>

<p>If that builds without errors, then it's time to start something up.</p>

<p>If you have problems you can't resolve
<a href="https://sourceforge.net/p/cyberprobe/discussion/">head to the discussion</a> forums.

<h2>Step 2: Establish network parameters</h2>

<p>
The simplest way to use cyberprobe is to use it on a Linux workstation,
pretty much like the one you're using now, and use it to capture all the
data going to/from the internet.  This will be a static configuration
in order to keep things simple.  We'll do dynamic tracking later.
</p>

<center><img src="simple-cyberprobe.png"/></center>

<p>In the next few steps, you'll use <code>cyberprobe</code> to capture some
data, on your workstation, and stream it to <code>etsi_rcvr</code> so
that you know it's working.  But first, you'll need to collect some information
about your configuration.
</p>

<p>
You need to know the name of the network interface you are using.  The
command <code>/sbin/ifconfig</code> will show you all the network interfaces
your machine knows about. e.g.
<pre>
lo: flags=73&lt;UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        [etc.]

eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.80  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::a60:6eff:fe81:7a75  prefixlen 64  scopeid 0x20<link>
        [etc.]
</pre>
<p>
The <code>lo</code> interface is a loopback interface, and isn't really on
the network, so ignore that.  It's an interface that gets packets going to
127.0.0.1 and makes sure they end up handled by your workstation.
Your interface is quite likely to be called something like <code>eth0</code>.
The other thing you need to know is the IP address of your workstation.
The IP address is associated with an interface, so 
in the above example, I can see I have an IP address 192.168.1.80.
</p>

<p>Note: on some networks (like mine) the IP address is allocated dynamically.
In my case, the IP address is allocated by the broadband router.  So,
you may need to keep a look out for it changing every an eye time you restart
your workstation.  In my case, I can tell the broadband router to
permanently allocate a particular IP address to this workstation.
</p>

<h2>Step 3: Starting <code>cyberprobe</code> with a configuration file</h2>

<p>The source code contains a file <code>config.xml</code> which is a 
good template for any configuration you're going to build.  However, for the
purpose of this discussion, let's start from scratch.  In order to do anything
useful, there are three essential elements to a cyberprobe configuration file:
interfaces, targets and endpoints.  The system won't do anything useful
without those three configuration elements defined.  Let's start with a
very simple configuration.</p>

<p>Using your favourite text editor, create a text file, say <code>c.xml</code>
with the following contents:
</p>
<pre>
&lt;?xml version="1.0" encoding="ISO-8859-1"?>

&lt;configuration>

  &lt;interfaces>
    &lt;interface name="eth0"/>
  &lt;/interfaces>

  &lt;targets>
  &lt;/targets>

  &lt;endpoints>
  &lt;/endpoints>

&lt;/configuration>
</pre>

<p>Note: You should replace the <code>eth0</code> string with the name of
your network interface.  Remember? We discovered that when playing with the
<code>ifconfig</code> command.</p>

<p>We're ready to roll.  We need to run as a privileged used because
<code>cyberprobe</code> captures data off the network interface.  So,
running as root, you need to locate the place where you compiled the
code, and run <code>cyberprobe</code> giving it the name of the configuration
file you just created:
</p>

<pre>
./cyberprobe c.xml
</pre>

<p>
If everything goes to plan, you should see the following output:
</p>

<pre>
Capture on interface eth0 started.
</pre>

<p>If you see an error message, the obvious two things to check are:
</p>

<ul>
<li>Did you name a network interface correctly?  See <code>ifconfig</code>
discussion above.</li>
<li>Are you running as a privileged user?</li>
</ul>

<p>If you see no output at all, check that your configuration file is correct.
</p>

<p>Once you are seeing the "Capture on interface eth0" line, then you've
achieved success in this step, and are ready to move on.
</p>

<p>If you have everything working, there's one thing to note before moving
on: <code>cyberprobe</code> treats a broken configuration file the same
as an empty configuration file.  With <code>cyberprobe</code> running, 
edit the configuration file, and delete the query (?) prefix in the first
line, so that it looks like this:
</p>

<pre>
&lt;xml version="1.0" encoding="ISO-8859-1"?>
</pre>

<p>You've now broken the configuration file.  It's not valid XML any more,
so the parsing fails.  You should see this output from
<code>cyberprobe</code>:
</p>

<pre>
Capture on interface eth0 stopped.
</pre>

<p>If you repair the damage to the configuration file, everything will
start working again.  The lesson here is: If you find that
<code>cyberprobe</code> won't recognise any resources, it's likely that your
configuration file is invalid.  The utility <code>xmlwf</code> can be useful 
to check that an XML configuration file is valid, if you're not getting
the results you expect.
</p>

<h2>Step 4: Adding a target</h2>

<p>We have <code>cyberprobe</code> running, but it isn't doing anything
useful.  Remember, I said that a useful configuration consists of three
minimal elements: interfaces, targets and endpoints?  Well, currently
we only have interfaces defined.  That means that <code>cyberprobe</code>
is capturing packets off of the network, but throwing them away.
</p>

<p>Let's add a target.  Edit the <code>targets</code> block of the
configuration file.  We need an entry describing
the IP address of my workstation.  Remember? We discovered that with the
<code>ifconfig</code> command earlier?  Instead of <code>192.168.1.80</code>
use the IP address of your workstation.</p>
<pre>
  &lt;targets>
    &lt;target address="192.168.1.80" liid="123456"/>
  &lt;/targets>
</pre>
<p>If successful, you should see new output from <code>cyberprobe</code>:</p>
<pre>
Added target 192.168.1.80 -> 123456.
</pre>

<p>At this step, we're capturing packets, spotting target addresses, but
as there's no endpoint defined there's still nowhere to send the data.
So, this is still a useless configuration.  On to the next step...</p>

<h2>Step 5: Adding an endpoint</h2>

<p>Adding an endpoint to the configuration file will define a place
where the captured data is sent.  Before adding an endpoint, let's make sure
there's something ready to receive the data.
</p>

<p>
In a separate terminal window, navigate to the Cyberprobe build, and run:
</p>

<pre>
./etsi_rcvr 10000 | tcpdump -n -r -
</pre>

<p>
The <code>etsi_rcvr</code> program opens a TCP port listening on port 10000
for a stream of ETSI data, and on standard output, writes the IP packets
it sees in PCAP format.  The <code>tcpdump</code> command receives this
PCAP data, and outputs packet summaries.
</p>

</p>If that starts successfully, the next step is to plumb a connection
from <code>cyberprobe</code> to <code>etsi_rcvr</code>.
</p>

<p>Next, edit the configuration file, and edit the <code>endpoints</code>
block to deliver packets to a local service on port 10000:
</p>
<pre>
  &lt;endpoints>
    &lt;endpoint hostname="localhost" port="10000" type="etsi"/>
  &lt;/endpoints>
</pre>

<p>
If that worked, you should see <code>cyberprobe</code> start the endpoint:
</p>

<pre>
Added endpoint localhost:10000 of type etsi
</pre>

<p>
Hopefully you'll start to see some output from <code>tcpdump</code>...
</p>

<h2>Step 6: Capturing data</h2>

<p>
At this step, <code>cyberprobe</code> should be forwarding an network
traffic your workstation generates to the <code>tcpdump</code> command, so
that you see data.  Any average workstation is generating network traffic
all the time, so you won't need to do anything.  But if you see nothing,
you can do something like, visit the Google home page in a browser on your
workstation.  You should see something like this pouring from the tcpdump.
</p>

<pre>
18:54:24.376838 IP 192.168.1.80.54249 > 212.58.244.71.http: Flags [P.], seq 
1:673, ack 1, win 115, options [nop,nop,TS val 129851063 ecr 3366955869], l
ength 672
18:54:24.390768 IP 212.58.244.71.http > 192.168.1.80.54249: Flags [.], ack 
673, win 124, options [nop,nop,TS val 3366955882 ecr 129851063], length 0
18:54:24.392909 IP 212.58.244.71.http > 192.168.1.80.54249: Flags [P.], seq 
1:1796, ack 673, win 124, options [nop,nop,TS val 3366955884 ecr 129851063],
 length 1795
</pre>

<p>
At this step, it's worth having a quick play with the reconnection
mechanism.  Stop and start <code>etsi_rcvr</code>, and you'll see that
<code>cyberprobe</code> reconnects automatically:</p>

<pre>
ETSI LI connection to localhost:10000 failed.
Will reconnect...
ETSI LI connection to localhost:10000 established.
</pre>
<p>We don't guarantee zero data loss on a reconnect.
</p>

<h2>Step 7: Management interface</h2>

<p>At this step, we'll setup a control port, and use it modify the
configuration of <code>cyberprobe</code>.
</p>

<p>First step is to modify the configuration file to include this line, just
after the <code>&lt;configuration></code> line:</p>

<pre>
  &lt;control port="8888" username="admin" password="mypassword"/>
</pre>

<p>That declares that a management service needs to be run on port 8888.
The authentication details are provided too.
You should see this output from <code>cyberprobe</code>:</p>

<pre>
Starting control on port 8888
</pre>

<p>That's good!  Now need to connect and interrogate the targets list:
I use <code>telnet</code> to connect, the <code>auth</code> command to
authenticate, and the <code>target</code> command to see a list of commands.
</p>

<pre>
$ <span style="color: red">telnet localhost 8888</span>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<span style="color: red">auth admin mypassword</span>
200 Authenticated.
<span style="color: red">targets</span>
201 Targets list follows.
25
123456:ipv4:192.168.1.80
</pre>

<p>I can use the <code>help</code> command to see the full list of commands
permitted.  There are commands for changing the address target list:
</p>

<pre>
<span style="color: red">targets</span>
201 Targets list follows.
25
123456:ipv4:192.168.1.80
<span style="color: red">remove_target ipv4 192.168.1.80</span>
200 Removed target.
<span style="color: red">add_target 654321 ipv4 192.168.1.80</span>
200 Added target.
</pre>

<p>The interface isn't pretty, but you get the idea.  You can change almost
everything that you can manage by changing the configuration file.
</p>

<p>Note: The the management interface changes the active state of
<code>cyberprobe</code> but it doesn't change the configuration file.  So,
configuration changes made through the management interface are 'lost' when
you restart <code>cyberprobe</code>.
</p>

<p>Note also that you may get some weird results if you use the
configuration file AND the control interface to manage the same resources,
so you probably don't want to do that.
</p>

<h2>Step 8: Integration with Snort</h2>

<p>In this step, we'll add the excellent IDS, Snort to the mix.
If you don't know Snort, it scans network traffic for patterns, and
can take various actions when those patterns are discovered.  It is typically
used to detect network attacks, and the Snort folks maintain a huge collection
of patterns that will identify known network attacks.  The Snort team
maintain the project at <a href="http://www.snort.org/">www.snort.org</a>.
<p>

<center><img src="cyberprobe-snort.png"/></center>

<p>
If you want to try out the Snort integration, you need to head over to the
Snort home page, download and install Snort.
</p>

<p>
Once you have it installed, to simplify things, you'll want to put a rule
in place that will definitely identify things on your network.  The easiest
way is to add a local rule that identifies your workstation.  First of all,
you'll want to make sure your Snort configuration file
(<code>/etc/snort/snort.conf</code>) loads a local rules file.  So, it should
contain something like this:
</p>

<pre>
# site specific rules
include $RULE_PATH/local.rules
</pre>

<p>Then, to identify your workstation, add a rule like this to your local
rules file (<code>/etc/snort/rules/local.rules</code>):
</p>

<pre>
alert tcp 192.168.1.80 any -> any 80 (msg:"Web"; classtype:misc-activity; sid:200; rev:1;)
</pre>

<p>Cyberprobe itself needs to be configured to receive Snort alerts.  You
do that by adding some configuration, just after the
<code>&lt;configuration></code> line:</p>

<pre>
   &lt;snort_alert socket="/var/log/snort/snort_alert" duration="60"/>
</pre>

<p>That says, Snort alerts will result in dynamic collection of data for
60 seconds from identification.  While you're in the configuration file,
you can remove the static IP
address target line.  Find this line and delete it:
</p>

<pre>
    &lt;target address="192.168.1.80" liid="123456"/>
</pre>

<p>
Cyberprobe should respond:
</p>
<pre>
Removed target 192.168.1.80 -> 123456.
Start snort alerter on /var/log/snort/snort_alert
</pre>



Now I can run Snort in IDS mode.  Snort
needs to run as 'root':
</p>

<pre>
snort -i eth0 -A unsock -N -l /var/log/snort/ -c /etc/snort/snort.conf 
</pre>

<p>Thanks to our Snort rule, when our workstation generates network data,
Snort will detect it, trigger our rule, and alert Cyberprobe.  You should see
Cyberprobe say:
</p>
<pre>
Hit on signature ID 200, targeting 192.168.1.80
</pre>

<p>
Also, once the rule is triggered, you should see evidence of packet data
from the <code>tcpdump</code> command, as before.
Cyberprobe causes the targeting to time out after a period of time.  If
further alerts are seen, the targeting lifetime is targeted.  If no 
further alerts are seen the IP address targeting is deleted.
If you can convince your workstation to stop creating network data, by
e.g. not using it for a minute or so, then you should see the rule time out:
</p>
<pre>
Stopped targeting on 192.168.1.80
</pre>
<p>
In practice this may be harder than you think, as workstations generate
network traffic all the time.  You may have to turn off your email clients
and close the web browse.  Your attempt to silence your workstation may
be further thwarted by the operating system checking for patches without
you knowing.
</p>

<h2>Step 9: Introducing a delay</h2>

<p>
Your Snort integration suffers from a particular problem now.  The time
taken for Snort to inspect some packets, generate an alert and for
<code>cyberprobe</code>
to get the IP address targeted is not zero.  It is hard to measure, but
it is going to be a significant chunk of a millisecond.  The problem
is that by the time <code>cyberprobe</code> is targeting the IP address,
the network attcker's packets have long gone.  The result is, that
while <code>cyberprobe</code> is now targetting the attacker, it won't
capture the original network attack.
</p>

<p>Our solution is to introduce a packet delay in <code>cyberprobe</code>.
The packets entering cyberprobe are kept in a time-delay queue and are
processed once that delay expires.  You can configure a delay, by putting
the <code>delay</code> attribute in an interface specfication. e.g.
</p>
<pre>
  &lt;interfaces>
    &lt;interface name="eth0" delay="1"/>
  &lt;/interfaces>
</pre>

<p>A 1-second delay will be plenty enough.  You should be able to see
this delay in action: When you generate network traffic, you should be
able to see the delay between network activity taking place, and the
corresponding burst of activity from <code>tcpdump</code>.</p>

<h2>Step 10: Introducing Cybermon</h2>

<p>The previous 9 steps have all been about <code>cyberprobe</code>. If you've
got this far successfully, you pretty much know all there is to know about
<code>cyberprobe</code>.  It is time to start doing something more useful
with all that data you are capturing.  In this step we'll start up
<code>cybermon</code> and look at the data.
</p>

<center><img src="cyberprobe-cybermon.png"/></center>

<p>
So, that <code>etsi_rcvr</code> you started in step 5?  Stop that, and 
start <code>cybermon</code>.  Two arguments are needed: A TCP port number
to receive the data on, and a configuration which tells it what to do.
A number of configuration files are bundled in with the source code, there
should be a basic one called <code>cybermon.lua</code>:
</p>

<pre>
./cybermon 10000 cybermon.lua
</pre>

<p>
Now when you generate network traffic, some of the traffic will be presented
in a reasonably intelligent form.  For example, I do a naming service
lookup for <code>www.google.com</code>...
</p>

<pre>
host -t a www.slashdot.org
</pre>

<p>The DNS protocol is parsed, and presented in a human readable form.  I can
see the request, and the response:
</p>

<pre>
SNORTc0a80150: 192.168.1.80:54633 -> 192.168.1.1:53. DNS query
    Query: www.slashdot.org

SNORTc0a80150: 192.168.1.1:53 -> 192.168.1.80:54633. DNS response
    Query: www.slashdot.org
    Answer: www.slashdot.org -> 216.34.181.48
</pre>

<p>
I see the query travelling from my workstation to the broadband router,
and then the response from the broadband router contains an answer field
mapping the name to an address.  HTTP protocols are also decoded.  Get
the Slashdot home page...
</p>

<pre>
wget -O- 'http://www.slashdot.org/'
</pre>

<p>...and amongst all the other stuff, you see the HTTP request and
response...
</p>

<pre>
SNORTc0a80150: 192.168.1.80:34284 -> 216.34.181.45:80. HTTP GET request
    URL /
    Connection: Keep-Alive
    User-Agent: Wget/1.14 (linux-gnu)
    Host: slashdot.org
    Accept: */*

SNORTc0a80150: 216.34.181.45:80 -> 192.168.1.80:34284. HTTP response 200 OK
    URL http://slashdot.org/
    Connection: keep-alive
    Content-Length: 113468
    Date: Mon, 26 Aug 2013 13:13:25 GMT
    Age: 17
    X-Varnish: 1493567531 1493567417
    X-XRDS-Location: http://slashdot.org/slashdot.xrds
    Cache-Control: no-cache
    Vary: Accept-Encoding
    SLASH_LOG_DATA: shtml
    Pragma: no-cache
    Content-Type: text/html; charset=utf-8
    Server: Apache/2.2.3 (CentOS)
</pre>

<h2>Step 11: Trying other configuration files</h2>

<p>
In the previous step, you started <code>cybermon</code> with the 
<code>cybermon.lua</code> configuration file.  Have a play with a couple
of the others.  Configuration file <code>hexdump.lua</code> produces
little hex dumps of things like HTTP bodies:
</p>

<pre>
cybermon 10000 hexdump.lua
</pre>

<p>
Configuration file <code>dump.lua</code> causes cybermon to dump the
information to files in the <code>data</code> directory.
</p>

<pre>
mkdir data
cybermon 10000 dump.lua
</pre>

<p>The <code>quiet.lua</code> configuration file does nothing.  It may be
a good place to start hacking your own configuration file.  Which is exactly
what we'll do in the next step.
</p>

<h2>Step 12: Writing your own configuration file</h2>

<p>
So, take a copy of the <code>quiet.lua</code> configuration file, and have
a look at it.  It consists of a bunch of functions written in the LUA
language.  LUA is a lightweight scripting langauge which is really good as a
configuration language.  For example, this function is called when a TCP
connection is made:
</p>

<pre>
observer.connection_up = function(context)
end
</pre>

<p>
And this function is called when an HTTP response is observed:
</p>

<pre>
observer.http_response = function(context, code, status, header, url, body)
end
</pre>

<p>
Let's get hacking!  The <code>header</code> parameter is a LUA table which
contains key/value pairs from the header.  The <code>url</code> parameter
contains the full URL of the response.  The <code>body</code> parameter
contains the payload body as an empty string.  Let's start simple:
</p>

<pre>
observer.http_response = function(context, code, status, header, url, body)
  print(url)
end
</pre>

<p>Then run that up...</p>

<pre>
./cybermon 10000 my.lua
</pre>

<p>Now, do some web browsing, and you should see a list of URLs flying past.
Each web page typically consists of several HTTP requests, but you should be
able to see the URLs associated with all of the web pages you visit.
Let's tart that up a little more: 
</p>

<pre>
-- This function is called when an HTTP response is observed.
observer.http_response = function(context, code, status, header, url, body)

  -- Take first 40 characters of URL
  local u = url:sub(1,40)

  -- Get Content-Type (first 20 characters)
  local ct
  ct = ""
  for key, value in pairs(header) do
    if key:lower() == "content-type" then
      ct = value:sub(1,20)
    end
  end

  io.write(string.format("%-40s %-20s %d\n", u, ct, #body))

end
</pre>

<p>That basically outputs three columns: The URL (truncated to 40 characters),
the body content type (truncated to 20 characters) and the HTTP response
payload length.  Here's what I get from visiting Slashdot:
</p>

<pre>
http://widget-cdn.rpxnow.com/manifest/sh text/javascript;char 42980
http://slashdot.org/                     text/html; charset=u 40105
http://ad.doubleclick.net/adj/ostg.slash text/javascript; cha 5625
http://pagead2.googlesyndication.com/pag application/x-shockw 33347
http://ad.doubleclick.net/adj/ostg.slash text/javascript; cha 540
http://ad.doubleclick.net/adj/ostg.slash text/javascript; cha 42
http://ad.doubleclick.net/adj/ostg.slash text/javascript; cha 452
http://pagead2.googlesyndication.com/pag                      0
</pre>

<h2>Step 13: Forging a TCP reset</h2>

<p>
So far, this has all been very passive.  It's time to make some noise!
From the LUA functions, there are a couple of functions available which allow
you to put some packets back onto the network.
</p>

<p>But first... there's a problem.  You remember in step 9,
we added a delay?  That's not going to work with packet forgery, because
by the time we've forged a packet and sent it on to the network, it's about
a second late.  So, we need to change our interface back so that there's no
delay on the interface.  That means, we're monitoring network data, but we'll
miss the original attack which triggered a Snort alert.
</p>

<pre>
    &lt;interface name="eth0"/>
</pre>

<p>The LUA interface passes a <code>context</code> variable to many of the
LUA functions, which gives access to <code>cybermon</code> information and
the packet forgery functions.  In this step, we're going to forge a TCP
reset on any connections which are from or to port 80.  Hack the configuration
file:
</p>

<pre>
observer.connection_up = function(context)

    -- Get TCP ports.
    local cls, src_addr, dest_addr
    cls, src_addr = context:get_src_addr()
    cls, dest_addr = context:get_dest_addr()

    -- check if it is port 80.
    if not((src_addr == "80") or (dest_addr == "80")) then
      -- Ignore non-HTTP traffic
      return
    end

    -- TCP reset    
    print("Spike! on HTTP connection.")
    context:forge_tcp_reset(context)

end
</pre>

<p>
Now before we go any further, <code>cybermon</code> needs to run as root in
order to use either of the packet forgery functions.  Packet forgery
needs access to the raw IP socket layer, which is a privileged operation.
Start that up:
</p>

<pre>
./cybermon 10000 my.lua
</pre>

<p>
Now start web browsing, and you should see a bunch of "Spike! on HTTP
connection" messages.  Also, you'll see a page saying "The connection was
reset" in your web browser.  That's a fairly anti-social configuration to
run on any network.  See the <code>tcp_reset.lua</code> example for a more
useful configuration.  It disrupts network traffic going to/from an SSH
server which isn't from your administration workstation.
</p>

<p>On any network with an SSH service open to the outside world, you might want
to use firewall rules to prevent access to the SSH service from addresses
outside of your network, but you could use <code>cybermon</code> as a
belt-and-braces protection mechanism.</p>

<p>Another example is where you know the user community on your network is
being targeted by phishing emails.  Your first step is to try to get the
phishing emails out of their inboxes, getting your email provider to filter
the attacks.  But a backup attack would be to make sure your users can't
get to the phisher's web site.  The <code>http_request</code> function allows
us to reset requests going to a particular web site.
</p>

<pre>
-- This function is called when an HTTP request is observed.
observer.http_request = function(context, method, url, header, body)

    if header["Host"] == "example.org" then
      print("Spike! on HTTP request")
      context:forge_tcp_reset(context)
    end

    if header["Host"] == "www.example.org" then
      print("Spike! on HTTP request")
      context:forge_tcp_reset(context)
    end

end
</pre>

<h2>Step 14: Forging a DNS response</h2>

<p>In this step, we'll detect a particular DNS request, and forge a response.
First of all, you'll need to familiarise yourself with <code>host</code>
which is a useful DNS test tool.  e.g.
</p>

<pre>
$ <span style="color: red">host -t a example.org</span>
example.org has address 93.184.216.119
</pre>

<p>The example.org name has been resolved to a particular IP address.
Let's hack the DNS request function in <code>my.lua</code>:
</p>

<pre>
-- This function is called when a DNS message is observed.
observer.dns_message = function(context, header, queries, answers, auth, add)

  -- Check my assumptions.  Need a DNS query request, with one query,
  -- name is example.org, type 'A', class 'IN'.
  if header.qr == 0 and #queries == 1 and queries[1].name == "example.org"
    and queries[1].type == 1 and queries[1].class == 1 then

    -- Send a fake response

    -- Set query/response flag to 'response'
    header.qr = 1

    -- 1 answer
    answers = {}
    answers[1] = {}
    answers[1].name = "example.org"
    answers[1].type = 1
    answers[1].class = 1
    answers[1].rdaddress = "1.2.3.4"

    -- 1 answer
    header.ancount = 1

    io.write("Forging DNS response!\n")

    context:forge_dns_response(context, header, queries, answers, {}, {})

  end

end
</pre>

<p>
So, this example, checks that the query is one we want to mess with.  If it
is, we turn the query structures into response structures, and hand them
back to <code>cybermon</code> to do a forgery.  The above example forges the
address <code>1.2.3.4</code>.  Start up <code>cybermon</code> with the script:
</p>

<pre>
./cybermon 10000 my.lua
</pre>

<p>If everything is working your <code>host</code> command will show a different
result:
</p>

<pre>
$ <span style="color: red">host -t a example.org</span>
example.org has address 1.2.3.4
</pre>

<p>Haha!  Spike!  DNS forgery has applications in blocking access to a phishers
resources on the internet, you might want to redirect your users to an
address which is inside your network.
</p>

<p>All done, I hope you enjoyed the tutorial!  The
<a href="cybermon.html">Cybermon</a> reference page details the LUA interface
in detail if you want to find out what else you can do in your LUA code.
</p>

</body>

</html>

