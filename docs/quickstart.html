<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<title>cyberprobe - Quick Start</title>

<style type="text/css" media="all">
@import "cyberprobe.css";
</style>

</head>
<body>
<h1>Cyberprobe - Quick Start</h1>

<h2>Table of contents</h2>

<ul>
<li><a href="index.html">Overview</a></li>
<li><a href="quickstart.html">Quick Start tutorial</a></li>
<li><a href="config.html">Configuration</a></li>
<li><a href="output.html">Output streaming protocols</a></li>
<li><a href="management.html">Management interface</a></li>
<li><a href="cybermon.html">Cybermon</a></li>
<li><a href="licence.html">Licence</a></li>
</ul>

<h2>Quick-start index</h2>

<p>This page covers how to get started with minimal reading of stuff.
To run through this tutorial, you will need to run some code with elevated
privileges than a normal 'user' has.  The easiest way to get through this
tutorial is to run the appropriate components as the 'root' user a.k.a. Super
User.
</p>

<ul>
<li><a href="#cyberprobe">Cyberprobe</a>
<ul>
<li><a href="#build">Build the software</a></li>
<li><a href="#network">Establish your network parameters</a></li>
<li><a href="#starting-cyberprobe">Starting cyberprobe</a></li>
<li><a href="#add-target">Adding a target</a></li>
<li><a href="#add-endpoint">Adding an endpoint</a></li>
<li><a href="#capturing">Capturing data</a></li>
<li><a href="#management">Management interface</a></li>
<li><a href="#snort">Integration with Snort</a></li>
<li><a href="#delay">Introducing a delay</a></li>
</ul>
</li>
<li><a href="#cybermon">Cybermon</a>
<ul>
<li><a href="#introducing-cybermon">Introducing Cybermon</a></li>
<li><a href="#configurations">Trying other configurations</a></li>
<li><a href="#write-configuration">Writing your own configuration</a></li>
<li><a href="#forge-tcp-reset">Forging a TCP reset</a></li>
<li><a href="#forge-dns-response">Forging a DNS response</a></li>
</ul>
<li><a href="#visualisation">Visualisation</a>
<ul>
<li><a href="#storing">Storing observations</a></li>
<li><a href="#visualising">Visualising observations</a></li>
</ul>
<li><a href="#stix">Cyber threat indicators using STIX</a>
<ul>
<li><a href="#stix-service">A STIX document service</a></li>
<li><a href="#stix-deploying">Deploying threat information to Cybermon</a></li>
</ul>
</ul>

<a name="cyberprobe"/>
<h2>Chapter I: Cyberprobe</h2>

<a name="build"/><h3>Step 1: Build software</h3>

<p>There's a fair amount of development taking place in the git repository,
so you probably want to get the  latest release on the 
<a href="http://sourceforge.net/projects/cyberprobe/files/">downloads</a>
page.  Download, unpack, and compile.  The configure option 'prefix' can be
used to say where the software will install.  Choose a location or go with
<code>/usr/local</code>
</p>

<pre>
./configure --prefix=/usr/local
make
sudo make install
</pre>

<p>
But if you do want to track the latest code, checkout the latest code from git:
</p>
<pre>
git clone http://git.code.sf.net/p/cyberprobe/code cyberprobe
</pre>

<p>Compilation is a little more long-winded if you use the git source:
</p>

<pre>
aclocal
autoconf
autoheader
automake
./configure --prefix=/usr/local
make
sudo make install
</pre>

<p>The code doesn't have many dependencies.  Exotic dependencies are:</p>
<ul>
<li>Boost regex.</li>
<li>Boost shared pointer.</li>
<li>LUA - 5.1 or later.</li>
<li>GCC C++ compiler and development support.</li>
<li>libpcap.</li>
<li>Expat (XML parser).</li>
<li>tcpdump - not needed to build the software, but we use it in this
tutorial.</li>
<li>telnet - not needed to build the software, but we use it in this tutorial.
</li>
</ul>

<p>
Note: on many platforms, installing a package just adds the "run time" part
of the code.  In order to be able to compile code against the run time, you
need to install a separate "developers kit" package.  On Fedora, for
instance, both <code>libpcap</code> and <code>libpcap-devel</code> are
needed in order to be able to build this code.
</p>

<p>The compilation process compiles the following executables:
</p>

<table>
<tr><td><code>cyberprobe</code></td><td>The Cyber Probe executable.</td></tr>
<tr><td><code>cybermon</code></td><td>Data analyser, analyses the data streams and reports events.</td></tr>
<tr><td><code>etsi_rcvr</code></td><td>Test decoder for ETSI format data.</td></tr>
<tr><td><code>nhis11_rcvr</code></td><td>Test decoder for NHIS1.1 format data.</td></tr>
<tr><td><code>cybermon_cli</code></td><td>Cyberprobe control command-line client.</td></tr>
</table>

<p>There isn't anything in the code to manage packaging yet.</p>

<p>If that builds without errors, then it's time to start something up.</p>

<p>If you have problems you can't resolve
<a href="https://sourceforge.net/p/cyberprobe/discussion/">head to the discussion</a> forums.

<a name="network"/><h3>Step 2: Establish network parameters</h3>

<p>
The simplest way to use cyberprobe is to use it on a Linux workstation,
pretty much like the one you're using now, and use it to capture all the
data going to/from the internet.  This will be a static configuration
in order to keep things simple.  We'll do dynamic tracking later.
</p>

<center><img src="simple-cyberprobe.png"/></center>

<p>In the next few steps, you'll use <code>cyberprobe</code> to capture some
data, on your workstation, and stream it to <code>etsi_rcvr</code> so
that you know it's working.  But first, you'll need to collect some information
about your configuration.
</p>

<p>
You need to know the name of the network interface you are using.  The
command <code>/sbin/ifconfig</code> will show you all the network interfaces
your machine knows about. e.g.
<pre>
lo: flags=73&lt;UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        [etc.]

eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.1.80  netmask 255.255.255.0  broadcast 192.168.1.255
        inet6 fe80::a60:6eff:fe81:7a75  prefixlen 64  scopeid 0x20<link>
        [etc.]
</pre>
<p>
The <code>lo</code> interface is a loopback interface, and isn't really on
the network, so ignore that.  It's an interface that gets packets going to
<code>127.0.0.1</code> and makes sure they end up handled by your workstation.
Your interface is quite likely to be called something like <code>eth0</code>.
The other thing you need to know is the IP address of your workstation.
The IP address is associated with an interface, so 
in the above example, I can see I have an IP address <code>192.168.1.80</code>.
</p>

<p>Note: on some networks (like mine) the IP address is allocated dynamically.
In my case, the IP address is allocated by the broadband router.  If things
aren't working as you expect, you should check your IP address to check your
workstation hasn't been allocated a new, different address.
In my case, I can tell the broadband router to
permanently allocate a particular IP address to this workstation, so that it
won't change.
</p>

<a name="starting-cyberprobe"/>
<h3>Step 3: Starting <code>cyberprobe</code> with a configuration file</h3>

<p>The source code contains a file <code>config.xml</code> which is a 
good template for any configuration you're going to build.  However, for the
purpose of this discussion, let's start from scratch.  In order to do anything
useful, there are three essential elements to a cyberprobe configuration file:
interfaces, targets and endpoints.  The system won't do anything useful
without those three configuration elements defined.  Let's start with a
very simple configuration.</p>

<p>Using your favourite text editor, create a text file, say <code>c.xml</code>
with the following contents:
</p>
<pre>
&lt;?xml version="1.0" encoding="ISO-8859-1"?>

&lt;configuration>

  &lt;interfaces>
    &lt;interface name="eth0"/>
  &lt;/interfaces>

  &lt;targets>
  &lt;/targets>

  &lt;endpoints>
  &lt;/endpoints>

&lt;/configuration>
</pre>

<p>Note: You should replace the <code>eth0</code> string with the name of
your network interface.  Remember? We discovered that when playing with the
<code>ifconfig</code> command.</p>

<p>We're ready to roll.  We need to run as a privileged used because
<code>cyberprobe</code> captures data off the network interface.  So,
running as root, you need to locate the place where you compiled the
code, and run <code>cyberprobe</code> giving it the name of the configuration
file you just created:
</p>

<pre>
cyberprobe c.xml
</pre>

<p>
If everything goes to plan, you should see the following output:
</p>

<pre>
Capture on interface eth0 started.
</pre>

<p>If you see an error message, the obvious two things to check are:
</p>

<ul>
<li>Did you name a network interface correctly?  See <code>ifconfig</code>
discussion above.</li>
<li>Are you running as a privileged user?</li>
</ul>

<p>If you see no output at all, check that your configuration file is correct.
</p>

<p>Once you are seeing the "Capture on interface eth0" line, then you've
achieved success in this step, and are ready to move on.
</p>

<p>If you have everything working, there's one thing to note before moving
on: <code>cyberprobe</code> treats a broken configuration file the same
as an empty configuration file.  With <code>cyberprobe</code> running, 
edit the configuration file, and delete the query (?) prefix in the first
line, so that it looks like this:
</p>

<pre>
&lt;xml version="1.0" encoding="ISO-8859-1"?>
</pre>

<p>You've now broken the configuration file.  It's not valid XML any more,
so the parsing fails.  You should see this output from
<code>cyberprobe</code>:
</p>

<pre>
Capture on interface eth0 stopped.
</pre>

<p>If you repair the damage to the configuration file, everything will
start working again.  The lesson here is: If you find that
<code>cyberprobe</code> won't recognise any resources, it's likely that your
configuration file is invalid.  The utility <code>xmlwf</code> can be useful 
to check that an XML configuration file is valid, if you're not getting
the results you expect.
</p>

<a name="add-target"/>
<h3>Step 4: Adding a target</h3>

<p>We have <code>cyberprobe</code> running, but it isn't doing anything
useful.  Remember, I said that a useful configuration consists of three
minimal elements: interfaces, targets and endpoints?  Well, currently
we only have interfaces defined.  That means that <code>cyberprobe</code>
is capturing packets off of the network, but throwing them away.
</p>

<p>Let's add a target.  Edit the <code>targets</code> block of the
configuration file.  We need an entry describing
the IP address of my workstation.  Remember? We discovered that with the
<code>ifconfig</code> command earlier?  Instead of <code>192.168.1.80</code>
use the IP address of your workstation.</p>
<pre>
  &lt;targets>
    &lt;target address="192.168.1.80" liid="123456"/>
  &lt;/targets>
</pre>
<p>If successful, you should see new output from <code>cyberprobe</code>:</p>
<pre>
Added target 192.168.1.80 -> 123456.
</pre>

<p>At this step, we're capturing packets, spotting target addresses, but
as there's no endpoint defined there's still nowhere to send the data.
So, this is still a useless configuration.  On to the next step...</p>

<a name="add-endpoint"/>
<h3>Step 5: Adding an endpoint</h3>

<p>Adding an endpoint to the configuration file will define a place
where the captured data is sent.  Before adding an endpoint, let's make sure
there's something ready to receive the data.
</p>

<p>
In a separate terminal window, navigate to the Cyberprobe build, and run:
</p>

<pre>
etsi_rcvr 10000 | tcpdump -n -r -
</pre>

<p>
The <code>etsi_rcvr</code> program opens a TCP port listening on port 10000
for a stream of ETSI data, and on standard output, writes the IP packets
it sees in PCAP format.  The <code>tcpdump</code> command receives this
PCAP data, and outputs packet summaries.
</p>

</p>If that starts successfully, the next step is to plumb a connection
from <code>cyberprobe</code> to <code>etsi_rcvr</code>.
</p>

<p>Next, edit the configuration file, and edit the <code>endpoints</code>
block to deliver packets to a local service on port 10000:
</p>
<pre>
  &lt;endpoints>
    &lt;endpoint hostname="localhost" port="10000" type="etsi"/>
  &lt;/endpoints>
</pre>

<p>
If that worked, you should see <code>cyberprobe</code> start the endpoint:
</p>

<pre>
Added endpoint localhost:10000 of type etsi
</pre>

<p>
Hopefully you'll start to see some output from <code>tcpdump</code>...
</p>

<a name="capturing"/>
<h3>Step 6: Capturing data</h3>

<p>
At this step, <code>cyberprobe</code> should be forwarding an network
traffic your workstation generates to the <code>tcpdump</code> command, so
that you see data.  Any average workstation is generating network traffic
all the time, so you won't need to do anything.  But if you see nothing,
you can do something like, visit the Google home page in a browser on your
workstation.  You should see something like this pouring from the tcpdump.
</p>

<pre>
18:54:24.376838 IP 192.168.1.80.54249 > 212.58.244.71.http: Flags [P.], seq 
1:673, ack 1, win 115, options [nop,nop,TS val 129851063 ecr 3366955869], l
ength 672
18:54:24.390768 IP 212.58.244.71.http > 192.168.1.80.54249: Flags [.], ack 
673, win 124, options [nop,nop,TS val 3366955882 ecr 129851063], length 0
18:54:24.392909 IP 212.58.244.71.http > 192.168.1.80.54249: Flags [P.], seq 
1:1796, ack 673, win 124, options [nop,nop,TS val 3366955884 ecr 129851063],
 length 1795
</pre>

<p>
At this step, it's worth having a quick play with the reconnection
mechanism.  Stop and start <code>etsi_rcvr</code>, and you'll see that
<code>cyberprobe</code> reconnects automatically:</p>

<pre>
ETSI LI connection to localhost:10000 failed.
Will reconnect...
ETSI LI connection to localhost:10000 established.
</pre>
<p>We don't guarantee zero data loss on a reconnect.
</p>

<a name="management"/>
<h3>Step 7: Management interface</h3>

<p>At this step, we'll setup a control port, and use it modify the
configuration of <code>cyberprobe</code>.
</p>

<p>First step is to modify the configuration file to include this line, just
after the <code>&lt;configuration></code> line:</p>

<pre>
  &lt;control port="8888" username="admin" password="mypassword"/>
</pre>

<p>That declares that a management service needs to be run on port 8888.
The authentication details are provided too.
You should see this output from <code>cyberprobe</code>:</p>

<pre>
Starting control on port 8888
</pre>

<p>That's good!  Now need to connect and interrogate the targets list:
I use <code>telnet</code> to connect, the <code>auth</code> command to
authenticate, and the <code>target</code> command to see a list of commands.
</p>

<pre>
$ <span style="color: red">telnet localhost 8888</span>
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
<span style="color: red">auth admin mypassword</span>
200 Authenticated.
<span style="color: red">targets</span>
201 Targets list follows.
25
123456:ipv4:192.168.1.80
</pre>

<p>I can use the <code>help</code> command to see the full list of commands
permitted.  There are commands for changing the address target list:
</p>

<pre>
<span style="color: red">targets</span>
201 Targets list follows.
25
123456:ipv4:192.168.1.80
<span style="color: red">remove_target ipv4 192.168.1.80</span>
200 Removed target.
<span style="color: red">add_target 654321 ipv4 192.168.1.80</span>
200 Added target.
</pre>

<p>The interface isn't pretty, but you get the idea.  You can change almost
everything that you can manage by changing the configuration file.
</p>

<p>Note: The the management interface changes the active state of
<code>cyberprobe</code> but it doesn't change the configuration file.  So,
configuration changes made through the management interface are 'lost' when
you restart <code>cyberprobe</code>.
</p>

<p>Note also that you may get some weird results if you use the
configuration file AND the control interface to manage the same resources,
so you probably don't want to do that.
</p>

<a name="snort"/>
<h3>Step 8: Integration with Snort</h3>

<p>In this step, we'll add the excellent IDS, Snort to the mix.
If you don't know Snort, it scans network traffic for patterns, and
can take various actions when those patterns are discovered.  It is typically
used to detect network attacks, and the Snort folks maintain a huge collection
of patterns that will identify known network attacks.  The Snort team
maintain the project at <a href="http://www.snort.org/">www.snort.org</a>.
<p>

<center><img src="cyberprobe-snort.png"/></center>

<p>
If you want to try out the Snort integration, you need to head over to the
Snort home page, download and install Snort.
</p>

<p>
Once you have it installed, to simplify things, you'll want to put a rule
in place that will definitely identify things on your network.  The easiest
way is to add a local rule that identifies your workstation.  First of all,
you'll want to make sure your Snort configuration file
(<code>/etc/snort/snort.conf</code>) loads a local rules file.  So, it should
contain something like this:
</p>

<pre>
# site specific rules
include $RULE_PATH/local.rules
</pre>

<p>Then, to identify your workstation, add a rule like this to your local
rules file (<code>/etc/snort/rules/local.rules</code>):
</p>

<pre>
alert tcp 192.168.1.80 any -> any 80 (msg:"Web"; classtype:misc-activity; sid:200; rev:1;)
</pre>

<p>Cyberprobe itself needs to be configured to receive Snort alerts.  You
do that by adding some configuration, just after the
<code>&lt;configuration></code> line:</p>

<pre>
   &lt;snort_alert socket="/var/log/snort/snort_alert" duration="60"/>
</pre>

<p>That says, Snort alerts will result in dynamic collection of data for
60 seconds from identification.  While you're in the configuration file,
you can remove the static IP
address target line.  Find this line and delete it:
</p>

<pre>
    &lt;target address="192.168.1.80" liid="123456"/>
</pre>

<p>
Cyberprobe should respond:
</p>
<pre>
Removed target 192.168.1.80 -> 123456.
Start snort alerter on /var/log/snort/snort_alert
</pre>



Now I can run Snort in IDS mode.  Snort
needs to run as 'root':
</p>

<pre>
snort -i eth0 -A unsock -N -l /var/log/snort/ -c /etc/snort/snort.conf 
</pre>

<p>Thanks to our Snort rule, when our workstation generates network data,
Snort will detect it, trigger our rule, and alert Cyberprobe.  You should see
Cyberprobe say:
</p>
<pre>
Hit on signature ID 200, targeting 192.168.1.80
</pre>

<p>
Also, once the rule is triggered, you should see evidence of packet data
from the <code>tcpdump</code> command, as before.
Cyberprobe causes the targeting to time out after a period of time.  If
further alerts are seen, the targeting lifetime is targeted.  If no 
further alerts are seen the IP address targeting is deleted.
If you can convince your workstation to stop creating network data, by
e.g. not using it for a minute or so, then you should see the rule time out:
</p>
<pre>
Stopped targeting on 192.168.1.80
</pre>
<p>
In practice this may be harder than you think, as workstations generate
network traffic all the time.  You may have to turn off your email clients
and close the web browse.  Your attempt to silence your workstation may
be further thwarted by the operating system checking for patches without
you knowing.
</p>

<a name="delay"/>
<h3>Step 9: Introducing a delay</h3>

<p>
Your Snort integration suffers from a particular problem now.  The time
taken for Snort to inspect some packets, generate an alert and for
<code>cyberprobe</code>
to get the IP address targeted is not zero.  It is hard to measure, but
it is going to be a significant chunk of a millisecond.  The problem
is that by the time <code>cyberprobe</code> is targeting the IP address,
the network attcker's packets have long gone.  The result is, that
while <code>cyberprobe</code> is now targetting the attacker, it won't
capture the original network attack.
</p>

<p>Our solution is to introduce a packet delay in <code>cyberprobe</code>.
The packets entering cyberprobe are kept in a time-delay queue and are
processed once that delay expires.  You can configure a delay, by putting
the <code>delay</code> attribute in an interface specfication. e.g.
</p>
<pre>
  &lt;interfaces>
    &lt;interface name="eth0" delay="0.2"/>
  &lt;/interfaces>
</pre>

<p>0.2 second should be plenty enough.  You should be able to see
this delay in action: When you generate network traffic, you should be
able to see the delay between network activity taking place, and the
corresponding burst of activity from <code>tcpdump</code>.</p>

<p>
At this point, you've completed the guided tour of <code>cyberprobe</code>,
the packet capture tool.  If that's all you need, the rest of the tutorial
will probably have less interest to you: In the following steps, we'll start
to analyse and act on the captured data.
</p>

<a name="cybermon"/>
<h2>Chapter II: Cybermon</h2>

<a name="introducing-cybermon"/>
<h3>Step 10: Introducing Cybermon</h3>

<p>The previous 9 steps have all been about <code>cyberprobe</code>. If you've
got this far successfully, you pretty much know all there is to know about
<code>cyberprobe</code>.  It is time to start doing something more useful
with all that data you are capturing.  In this step we'll start up
<code>cybermon</code> and look at the data.
</p>

<center><img src="cyberprobe-cybermon.png"/></center>

<p>
So, that <code>etsi_rcvr</code> you started in step 5?  Stop that, and 
start <code>cybermon</code>.  Two arguments are needed: A TCP port number
to receive the data on, and a configuration which tells it what to do.
A number of configuration files are bundled in with the source code, there
should be a basic one called <code>cybermon.lua</code> which is now installed
in the <code>etc</code> directory, depending on where you installed the
software:
</p>

<pre>
cybermon 10000 /usr/local/etc/cybermon.lua
</pre>

<p>
Now when you generate network traffic, some of the traffic will be presented
in a reasonably intelligent form.  For example, I do a naming service
lookup for <code>www.google.com</code>...
</p>

<pre>
host -t a www.slashdot.org
</pre>

<p>The DNS protocol is parsed, and presented in a human readable form.  I can
see the request, and the response:
</p>

<pre>
SNORTc0a80150: 192.168.1.80:54633 -> 192.168.1.1:53. DNS query
    Query: www.slashdot.org

SNORTc0a80150: 192.168.1.1:53 -> 192.168.1.80:54633. DNS response
    Query: www.slashdot.org
    Answer: www.slashdot.org -> 216.34.181.48
</pre>

<p>
I see the query travelling from my workstation to the broadband router,
and then the response from the broadband router contains an answer field
mapping the name to an address.  HTTP protocols are also decoded.  Get
the Slashdot home page...
</p>

<pre>
wget -O- 'http://www.slashdot.org/'
</pre>

<p>...and amongst all the other stuff, you see the HTTP request and
response...
</p>

<pre>
SNORTc0a80150: 192.168.1.80:34284 -> 216.34.181.45:80. HTTP GET request
    URL /
    Connection: Keep-Alive
    User-Agent: Wget/1.14 (linux-gnu)
    Host: slashdot.org
    Accept: */*

SNORTc0a80150: 216.34.181.45:80 -> 192.168.1.80:34284. HTTP response 200 OK
    URL http://slashdot.org/
    Connection: keep-alive
    Content-Length: 113468
    Date: Mon, 26 Aug 2013 13:13:25 GMT
    Age: 17
    X-Varnish: 1493567531 1493567417
    X-XRDS-Location: http://slashdot.org/slashdot.xrds
    Cache-Control: no-cache
    Vary: Accept-Encoding
    SLASH_LOG_DATA: shtml
    Pragma: no-cache
    Content-Type: text/html; charset=utf-8
    Server: Apache/2.2.3 (CentOS)
</pre>

<a name="configurations"/>
<h3>Step 11: Trying other configuration files</h3>

<p>
In the previous step, you started <code>cybermon</code> with the 
<code>cybermon.lua</code> configuration file.  Have a play with a couple
of the others.  Configuration file <code>hexdump.lua</code> produces
little hex dumps of things like HTTP bodies:
</p>

<pre>
cybermon 10000 /usr/local/etc/hexdump.lua
</pre>

<p>
Configuration file <code>dump.lua</code> causes cybermon to dump the
information to files in the <code>data</code> directory.
</p>

<pre>
mkdir data
cybermon 10000 /usr/local/etc/dump.lua
</pre>

<p>The <code>quiet.lua</code> configuration file does nothing.  It may be
a good place to start hacking your own configuration file.  Which is exactly
what we'll do in the next step.
</p>

<a name="write-configuration"/>
<h3>Step 12: Writing your own configuration file</h3>

<p>
So, take a copy of the <code>quiet.lua</code> configuration file, and have
a look at it.  It consists of a bunch of functions written in the LUA
language.  LUA is a lightweight scripting langauge which is really good as a
configuration language.  For example, this function is called when a TCP
connection is made:
</p>

<pre>
observer.connection_up = function(context)
end
</pre>

<p>
And this function is called when an HTTP response is observed:
</p>

<pre>
observer.http_response = function(context, code, status, header, url, body)
end
</pre>

<p>
Let's get hacking!  The <code>header</code> parameter is a LUA table which
contains key/value pairs from the header.  The <code>url</code> parameter
contains the full URL of the response.  The <code>body</code> parameter
contains the payload body as an empty string.  Let's start simple:
</p>

<pre>
observer.http_response = function(context, code, status, header, url, body)
  print(url)
end
</pre>

<p>Then run that up...</p>

<pre>
cybermon 10000 my.lua
</pre>

<p>Now, do some web browsing, and you should see a list of URLs flying past.
Each web page typically consists of several HTTP requests, but you should be
able to see the URLs associated with all of the web pages you visit.
Let's tart that up a little more: 
</p>

<pre>
-- This function is called when an HTTP response is observed.
observer.http_response = function(context, code, status, header, url, body)

  -- Take first 40 characters of URL
  local u = url:sub(1,40)

  -- Get Content-Type (first 20 characters)
  local ct
  ct = ""
  for key, value in pairs(header) do
    if key:lower() == "content-type" then
      ct = value:sub(1,20)
    end
  end

  io.write(string.format("%-40s %-20s %d\n", u, ct, #body))

end
</pre>

<p>That basically outputs three columns: The URL (truncated to 40 characters),
the body content type (truncated to 20 characters) and the HTTP response
payload length.  Here's what I get from visiting Slashdot:
</p>

<pre>
http://widget-cdn.rpxnow.com/manifest/sh text/javascript;char 42980
http://slashdot.org/                     text/html; charset=u 40105
http://ad.doubleclick.net/adj/ostg.slash text/javascript; cha 5625
http://pagead2.googlesyndication.com/pag application/x-shockw 33347
http://ad.doubleclick.net/adj/ostg.slash text/javascript; cha 540
http://ad.doubleclick.net/adj/ostg.slash text/javascript; cha 42
http://ad.doubleclick.net/adj/ostg.slash text/javascript; cha 452
http://pagead2.googlesyndication.com/pag                      0
</pre>

<a name="forge-tcp-reset"/>
<h3>Step 13: Forging a TCP reset</h3>

<p>
So far, this has all been very passive.  It's time to make some noise!
From the LUA functions, there are a couple of functions available which allow
you to put some packets back onto the network.
</p>

<p>But first... there's a problem.  You remember in step 9,
we added a delay?  That's not going to work with packet forgery, because
by the time we've forged a packet and sent it on to the network, it's too
late.  So, we need to change our interface back so that there's no
delay on the interface.  That means, we're monitoring network data, but we'll
miss the original attack which triggered a Snort alert.
</p>

<pre>
    &lt;interface name="eth0" delay="0.0"/>
</pre>

<p>Once you have this code working, you might be able to mess with the delay
parameter to see if you can pick a low-latency value that works for you.
On my network, the value <code>0.02</code> is low enough to
allow a response to allow packet forgery to work. Any higher, and the forged
packets are too late to beat the real packets.
</p>

<p>The LUA interface passes a <code>context</code> variable to many of the
LUA functions, which gives access to <code>cybermon</code> information and
the packet forgery functions.  In this step, we're going to forge a TCP
reset on any connections which are from or to port 80.  Hack the configuration
file:
</p>

<pre>
observer.connection_up = function(context)

    -- Get TCP ports.
    local cls, src_addr, dest_addr
    cls, src_addr = context:get_src_addr()
    cls, dest_addr = context:get_dest_addr()

    -- check if it is port 80.
    if not((src_addr == "80") or (dest_addr == "80")) then
      -- Ignore non-HTTP traffic
      return
    end

    -- TCP reset    
    print("Spike! on HTTP connection.")
    context:forge_tcp_reset(context)

end
</pre>

<p>
Now before we go any further, <code>cybermon</code> needs to run as root in
order to use either of the packet forgery functions.  Packet forgery
needs access to the raw IP socket layer, which is a privileged operation.
Start that up:
</p>

<pre>
cybermon 10000 my.lua
</pre>

<p>
Now start web browsing, and you should see a bunch of "Spike! on HTTP
connection" messages.  Also, you'll see a page saying "The connection was
reset" in your web browser.  That's a fairly anti-social configuration to
run on any network.  See the <code>tcp_reset.lua</code> example for a more
useful configuration.  It disrupts network traffic going to/from an SSH
server which isn't from your administration workstation.
</p>

<p>On any network with an SSH service open to the outside world, you might want
to use firewall rules to prevent access to the SSH service from addresses
outside of your network, but you could use <code>cybermon</code> as a
belt-and-braces protection mechanism.</p>

<p>Another example is where you know the user community on your network is
being targeted by phishing emails.  Your first step is to try to get the
phishing emails out of their inboxes, getting your email provider to filter
the attacks.  But a backup attack would be to make sure your users can't
get to the phisher's web site.  The <code>http_request</code> function allows
us to reset requests going to a particular web site.
</p>

<pre>
-- This function is called when an HTTP request is observed.
observer.http_request = function(context, method, url, header, body)

    if header["Host"] == "example.org" then
      print("Spike! on HTTP request")
      context:forge_tcp_reset(context)
    end

    if header["Host"] == "www.example.org" then
      print("Spike! on HTTP request")
      context:forge_tcp_reset(context)
    end

end
</pre>

<a name="forge-dns-response"/>
<h3>Step 14: Forging a DNS response</h3>

<p>In this step, we'll detect a particular DNS request, and forge a response.
First of all, you'll need to familiarise yourself with <code>host</code>
which is a useful DNS test tool.  e.g.
</p>

<pre>
$ <span style="color: red">host -t a example.org</span>
example.org has address 93.184.216.119
</pre>

<p>The example.org name has been resolved to a particular IP address.
Let's hack the DNS request function in <code>my.lua</code>:
</p>

<pre>
-- This function is called when a DNS message is observed.
observer.dns_message = function(context, header, queries, answers, auth, add)

  -- Check my assumptions.  Need a DNS query request, with one query,
  -- name is example.org, type 'A', class 'IN'.
  if header.qr == 0 and #queries == 1 and queries[1].name == "example.org"
    and queries[1].type == 1 and queries[1].class == 1 then

    -- Send a fake response

    -- Set query/response flag to 'response'
    header.qr = 1

    -- 1 answer
    answers = {}
    answers[1] = {}
    answers[1].name = "example.org"
    answers[1].type = 1
    answers[1].class = 1
    answers[1].rdaddress = "1.2.3.4"

    -- 1 answer
    header.ancount = 1

    io.write("Forging DNS response!\n")

    context:forge_dns_response(context, header, queries, answers, {}, {})

  end

end
</pre>

<p>
So, this example, checks that the query is one we want to mess with.  If it
is, we turn the query structures into response structures, and hand them
back to <code>cybermon</code> to do a forgery.  The above example forges the
address <code>1.2.3.4</code>.  Start up <code>cybermon</code> with the script:
</p>

<pre>
cybermon 10000 my.lua
</pre>

<p>If everything is working your <code>host</code> command will show a different
result:
</p>

<pre>
$ <span style="color: red">host -t a example.org</span>
example.org has address 1.2.3.4
</pre>

<p>Haha!  Spike!  DNS forgery has applications in blocking access to a phishers
resources on the internet, you might want to redirect your users to an
address which is inside your network.
</p>

<p>The <a href="cybermon.html">Cybermon</a> reference page details the LUA
interface in detail if you want to find out what else you can do in your
LUA code.
</p>

<a name="visualisation"/>
<h2>Chapter III: Visualisation</h2>

<p>
This is the most incomplete part of Cyberprobe.  Look at this part as
demonstrating what <i>might</i> be possible.  If you find this interesting,
and feel you could turn this into something more impressive, well... there's
a git check-in with your name on.
</p>

<a name="storing"/>
<h3>Step 15: Storing observations</h3>

<p>Now we need somewhere to store the observations which <code>cybermon</code>
discovers.  There are many candidates for a storage repository, but my
favourite for this sort of scenario is the excellent
<a href="http://www.elasticsearch.org">ElasticSearch</a>.  It is flexible,
offers a huge amount of functionality, and is incredibly simple to interface
with, thanks to its JSON API.  So, your next action is to head over
to the <a href="http://www.elasticsearch.org/download/">download</a> page
and get hold of the latest version.  I'm using version 1.3.2 to build
this tutorial but the ElasticSearch API has proven hugely stable, so should
work with the latest.
</p>

<p>Having downloaded the latest version, you unpack it, and run it e.g.
</p>

<pre>
tar xvfz elasticsearch-0.90.3.tar.gz
cd elasticsearch-0.90.3
bin/elasticsearch -f
</pre>

<p>Another brilliant thing about ElasticSearch is that it needs almost no
configuration to get an instance started.  You will need to make one
configuration change to ElasticSearch if there are other instances running on
your network: you need need to change <code>cluster.name</code> to some unique
string in <code>config/elasticsearch.yml</code>, otherwise your ElasticSearch
instance might join another cluster on your network, which could complicate
things.
</p>

<p>You can check you have ElasticSearch up and running using a command such
as this:
</p>

<pre>
wget -q -O- http://localhost:9200
</pre>

<p>The response will look something like this:</p>

<pre>{
  "ok" : true,
  "status" : 200,
  "name" : "Cybermon",
  "version" : {
    "number" : "0.90.3",
    "build_hash" : "5c38d6076448b899d758f29443329571e2522410",
    "build_timestamp" : "2013-08-06T13:18:31Z",
    "build_snapshot" : false,
    "lucene_version" : "4.4"
  },
  "tagline" : "You Know, for Search"
}</pre>

<p>Once ElasticSearch is running, you can get <code>cybermon</code> to load
observations into it by using the <code>cyberdb.lua</code> configuration file.
So if you're continuing the tutorial, you can stop <code>cybermon</code>,
and run:
</p>

<pre>cybermon 10000 /usr/local/etc/cyberdb.lua</pre>

<p>
After some network data has been observed, you should be able to see
results loaded into ElasticSearch using the following command:
</p>

<pre>
curl -s -XPOST "http://localhost:9200/cybermon/observation/_search?pretty=true" -d '
{
  "query" : {
    "match_all": {}
  }
}
'
</pre>

<p>
You should see some stuff which looks like data scrolling past on the screen.
If your response looks like the following result, that's not so good, as it
means there are no results.  See <code>hits.total</code>?  Zero means no
results.
</p>

<pre>
{
  "took" : 1,
  "timed_out" : false,
  "_shards" : {
    "total" : 5,
    "successful" : 5,
    "failed" : 0
  },
  "hits" : {
    "total" : 0,
    "max_score" : null,
    "hits" : [ ]
  }
}
</pre>

<p>
If you see a lot of information scrolling past on the screen, that's good.
</p>

<p>The <code>cyberdb.lua</code> configuration file maps the
<code>cybermon</code> observations into a form which is appropriate to store
in ElasticSearch.  Each observation is stored with a 60 second time-to-live,
to the information is not stored for long.
</p>

<a name="visualising"/>
<h3>Step 16: Visualising observations</h3>

<p>Having loaded the observations into ElasticSearch, it's easy to do some
visualisation.  Start up Firefox: you need to use
"Open File" on the File menu, navigate to your Cyberprobe build area, and load
load the page <code>www/index.html</code>.  If it all works correctly, the
page will query your ElasticSearch instance, and show a scrolling display
of stuff that cybermon sees.  The horizontal space depicts time, with 'now'
at the right-hand edge.  Thus, observations scroll gradually from right to
left.  The vertical space depicts the IP address space, so things resulting
from similar addresses appear close to each other.
</p>

<p>
All observations appear as a rectangle containing the action type, except
HTTP responses carrying images which also have a thumbnail attached.
</p>

<center><img class="screen" src="visualisation.png" width="400"/></center>

<a name="stix"/>
<h2>Chapter IV: Cyber threat indicators using STIX</h2>

<p>We've been experimenting with an open model for describing
cyber threats.  <a href="https://stix.mitre.org">STIX</a> is a community-driven
effort to standardise a model for cyber theat information.
<a href="http://taxii.mitre.org/">TAXII</a> defines a set of services for
distributing STIX information.  There's some support in Cyberprobe, but you
should know that this is very prototype at the moment.
</p>

<p>This is what we've got so far:</p>
<ul>
<li>There's a simple CSV file format we've created to describe cyber threats.
This is just for convenience.</li>
<li>A script, <code>stix-create</code> which reads the above configuration file,
and converts into a STIX document containing Indicator objects.</li>
<li>A script, <code>stix-server</code> which acts as a very simple TAXII
server, serving up STIX documents.</li>
<li>A script, <code>stix-client</code> which connects to a STIX server, gets
STIX documents and dumps some stuff out.</li>
<li>A script <code>stix-sync-json</code> which connects to a STIX server,
gets STIX documents, massages the whole lot into a single JSON form, and
dumps that to a file.</li>
<li>A configuration file for <code>cybermon</code> which reads the JSON 
threat information and reports when theats are observed.</li>
</ul>

<p>Before taking this any further, you need to have Python installed, along
with various dependencies (<code>pyOpenSSL</code>, <code>libtaxii</code> and
<code>stix</code>).  The easiest way to install the dependencies is
to install <code>pip</code>, and issue this command:
<pre>
sudo pip install libtaxii pyOpenSSL stix
</pre>

<a name="stix-service"/><h3>Step 17: A STIX document service</h3>

<p>
The installation bundle includes a couple of CSV files containing some
fictional cyber theats.  Search for example1.txt and example2.txt.  They
may be in <code>/usr/local/share/doc/cyberprobe</code> once you've installed
everything.  You need to create a data area, and convert these files into
STIX ready for serving:
</p>

<pre>
mkdir /tmp/stix
cd /tmp/stix
mkdir -p data/default
stix-create /usr/local/share/doc/cyberprobe/example1.txt data/default/1 -i ex:1
stix-create /usr/local/share/doc/cyberprobe/example2.txt data/default/2 -i ex:2
</pre>

<p>
Check that you have two new XML files in <code>data/default</code> directory.
If they're there, you're ready to start a STIX server.  This will run on
port 8080, so you'll need to use a different port number if you don't like
this one.  It's important that this is run from the directory where you
just created the data directory.
</p>

<pre>
taxii-server --port 8080
</pre>

<p>
If that works, use the test client to communicate:
</p>

<pre>
taxii-client --port 8080
</pre>

<p>And you should see some stuff that looks like cyber threat information
dumped on the screen.
</p>

<a name="stix-deploying"/>
<h3>Step 18: Deploying theat information to Cybermon</h3>

<p>Now, we use <code>taxii-sync-json</code> to fetch the STIX information
in a JSON form I can easily ingest into the LUA code:
</p>

<pre>
taxii-sync-json --port 8080
</pre>

<p>
This should create a JSON file called <code>stix-default-combined.json</code>.
</p>

<p>
Finally, stop any running cybermon processes, and run cybermon with a
configuration file which reads the JSON file.
</p>

<pre>cybermon 10000 /usr/local/etc/stix-alert.lua</pre>

<p>Now, this produces no output, except when activity which hits on a cyber
threat is observed.  If you used my sample data, then this activity should
trigger a theat:
</p>

<pre>
wget -q -O- http://www.malware.com/malware.dat
</pre>

<p>I should just say at this point, I have no idea if the malware.com site
is dodgy or not, it just seems to redirect to Wikipedia.  Hope they don't mind
us using them for this test.</p>

<p>If this works, you should see the following output:
</p>

<pre>
DNS query for www.malware.com, hits example1:5 (Hostname of malware server)!
DNS query for www.malware.com, hits example1:5 (Hostname of malware server)!
DNS response for www.malware.com, hits example1:5 (Hostname of malware server)!
DNS response for www.malware.com, hits example1:5 (Hostname of malware server)!
HTTP request to http://www.malware.com/malware.dat, hits example1:7 (URL of a page serving malware)!
HTTP request to www.malware.com, hits example1:5 (Hostname of malware server)!
HTTP response from http://www.malware.com/malware.dat, hits example1:7 (URL of a page serving malware)!
</pre>

<p>
This hits on a number of theat indicators.  The hostname
<code>www.malware.com</code> is present in a theat indicator, and it is
detected in the HTTP request, and both the DNS query and response.  Also,
the URL <code>http://www.malware.com/malware.dat</code> is in a threat
indicator and it is detected in both the HTTP request and response.
</p>

<p>
The <code>stix-alert.lua</code> configuration file updates its configuration
if the JSON configuration file has changed.  So, you can do a round-trip
update by changing the input files, re-running <code>stix-create</code>,
using <code>taxii-sync-json</code> to fetch the updates, and all without
stopping the monitoring.
</p>

<h2>Conslusion</h2>

<p>
All done, I hope you enjoyed the tutorial!  Any comments on the software,
or tutorial itself are very welcome!  Positive, or negative, we want to hear
how you found the experience.
</p>

</body>

</html>

