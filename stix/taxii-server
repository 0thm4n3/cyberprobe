#!/usr/bin/env python

import libtaxii as t
import libtaxii.messages_11 as tm11
import BaseHTTPServer
import time
import datetime
import os
from stix.core import STIXPackage, STIXHeader
import StringIO
import argparse
import libtaxii.taxii_default_query as tdq
from lxml import etree

# Uses a directory containing STIX documents.  Directory structure is...
#   <data_dir/<collection>/<document>

############################################################################
# Timezone class, representing GMT.
############################################################################
class GMT(datetime.tzinfo):
    """GMT"""

    def utcoffset(self, dt):
        return datetime.timedelta(0)

    def tzname(self, dt):
        return "GMT"

    def dst(self, dt):
        return datetime.timedelta(0)

# GMT timezone instance
gmt = GMT()

############################################################################
# HTTP request handler
#################################################################
class TaxiiHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    # Send a TAXII response payload
    def respond(s, body):

        # Send HTTP response
        s.send_response(200)
        s.send_header("Content-type", "text/xml")
        s.send_header("Content-length", len(body))
        s.send_header("X-TAXII-Content-Type", 
                      "urn:taxii.mitre.org:message:xml:1.1")
        s.send_header("X-TAXII-Protocol", 
                      "urn:taxii.mitre.org:protocol:http:1.0")
        s.send_header("X-TAXII-Services", 
                      "urn:taxii.mitre.org:services:1.1")
        s.end_headers()
        s.wfile.write(body)

    # Handling a TAXII InboxMessage
    def handle_inbox_message(s, msg):

        # Process each content block
        for cb in msg.content_blocks:

            content = cb.content

            # Hack an XML header on the top?! and add the payload body.
            resp = "<?xml version=\"1.0\"?>\n" + content

            # Parse the payload, should be a STIX document.
            package = STIXPackage.from_xml(StringIO.StringIO(resp))

            for collection in msg.destination_collection_names:

                # FIXME: Make sure this can't be used to write an arbitrary
                # file.
                path = os.path.join(data_dir, collection, package.id_)

                f = open(path, 'w')
                f.write(content)
                f.close()

                print "Wrote %s" % path

        resp = tm11.StatusMessage(message_id=tm11.generate_message_id(),
                                  in_response_to=msg.message_id,
                                  status_type=tm11.ST_SUCCESS)

        # Respond
        s.respond(resp.to_xml())
    
    # Apply a query criteria
    def apply_query_criteria(s, criteria, doc):

        for c in criteria.criteria:
            ret = s.apply_query_criteria(c, doc)
            if criteria.operator == 'AND' and ret == False:
                return False
            if criteria.operator == 'OR' and ret == True:
                return True

        for c in criteria.criterion:
            ret = s.apply_query_criterion(c, doc)
            if criteria.operator == 'AND' and ret == False:
                return False
            if criteria.operator == 'OR' and ret == True:
                return True

        if criteria.operator == 'AND':
            return True

        return False

    # Apply a query criterion
    def apply_query_criterion(s, criterion, doc):

        namespaces = {
            "cybox": "http://cybox.mitre.org/cybox-2",
            "AddressObject": "http://cybox.mitre.org/objects#AddressObject-2",
            "stix": "http://stix.mitre.org/stix-1",
            "HostnameObj": "http://cybox.mitre.org/objects#HostnameObject-1",
            "PortObj": "http://cybox.mitre.org/objects#PortObject-2",
            "cyboxCommon": "http://cybox.mitre.org/common-2"
        }

        # Convert target to XPath pointer part
        if criterion.target == '//Address_Value':
            expr = '//AddressObject:Address_Value'
        elif criterion.target == '//Indicator/@id':
            expr = '//stix:Indicator/@id'
        elif criterion.target == '//Package_Intent':
            expr = '//stix:Package_Intent'
        elif criterion.target == '//AddressObjectType':
            expr = '//cybox:Properties/AddressObj:AddressObjectType'
        elif criterion.target == '//Hostname_Value':
            expr = '//HostnameObj:Hostname_Value'
        elif criterion.target == '//Port_Value':
            expr = '//PortObj:Port_Value'
        elif criterion.target == '//Hash/Simple_Hash_Value':
            expr = '//cyboxCommon:Hash/cyboxCommon:Simple_Hash_Value'

        suffix = ''

        relationship = criterion.test.relationship
        params = criterion.test.parameters
        value = params['value']

        if relationship == 'equals':
            if params['match_type'] == 'case_sensitive_string':
                suffix = '[. = "%s"]' % value
            elif params['match_type'] == 'case_insensitive_string':
                suffix = '[translate(., "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz") = "%s"]' % value.lower()
            elif params['match_type'] == 'number':
                suffix = '[. = "%s"]' % value
        elif relationship == 'not equals':
            if params['match_type'] == 'case_sensitive_string':
                suffix = '[. != "%s"]' % value
            elif params['match_type'] == 'case_insensitive_string':
                suffix = '[translate(%s, "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz") != "%s"]' % value
            elif params['match_type'] == 'number':
                suffix = '[. != "%s"]' % value
        elif relationship == 'greater than':
            suffix = '[. > "%s"]' % value
        elif relationship == 'greater than or equal':
            suffix = '[. >= "%s"]' % value
        elif relationship == 'less than':
            suffix = '[. < "%s"]' % value
        elif relationship == 'less than or equal':
            suffix = '[. <= "%s"]' % value
        elif relationship == 'does not exist':
            expr = "not(%s)" % expr
        elif relationship == 'exists':
            # Complete
            pass
        elif relationship == 'begins with':
            if params['case_sensitive'] == 'false':
                suffix = '[starts-with(translate(., "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz"), "%s")]' % value
            elif params['case_sensitive'] == 'true':
                suffix = '[starts-with(., "%s")]' % value
        elif relationship == 'ends with':
            if params['case_sensitive'] == 'false':
                suffix = '[substring(translate(., "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz"), string-length(.) - string-length("%s") + 1) = "%s"]' % (value, value.lower())
        elif params['case_sensitive'] == 'true':
            suffix = '[substring(., string-length(.) - string-length("%s") + 1) = "%s"]' % (value, value.lower())
        elif relationship == 'contains':
            if params['case_sensitive'] == 'false':
                suffix = '[contains(translate(., "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyz"), "%s")]' % value()
            elif params['case_sensitive'] == 'true':
                suffix = '[contains(., "%s")]' % value()
        
        expr += suffix

        result = doc.xpath(expr, namespaces=namespaces)
        
        if result == True:
            ret = True
        elif result == False:
            ret = False
        elif len(result) > 0:
            ret = True
        else:
            ret = False

        if criterion.negate:
            return not ret
        else:
            return ret

    # Handling a TAXII PollRequest
    def handle_poll_request(s, msg):
        
        query = msg.poll_parameters.query

        # Get the time (now)
        now = datetime.datetime.now(gmt)

        # Construct pathname of collection.
        # FIXME: Security feature: Check collection name for attempts
        # to navigate outside of the data directory.
        dir = os.path.join(data_dir, msg.collection_name)

        # Get a list of files.
        flst = os.listdir(dir)

        # Start constructing the content block list
        cbs = []

        print "Building response..."

        # Need to record the newest timestamp of all the data files, this 
        # variable keeps track.
        latest = None

        # Iterate over file list.
        for file in flst:

            # Create filename
            fname = os.path.join(dir, file)

            # Stat in order to get the last modification time.
            st = os.stat(fname)
            then = datetime.datetime.fromtimestamp(st.st_mtime, gmt)

            # Check whether file's modification time falls within the
            # begin/end bounds.
            if msg.exclusive_begin_timestamp_label:
                if msg.exclusive_begin_timestamp_label >= then:
                    continue
            if msg.inclusive_end_timestamp_label:
                if msg.inclusive_end_timestamp_label < then:
                    continue

            # Open the file and read contents.
            f = open(fname, "r")
            content = f.read()
            f.close()

            if query != None:

                # Parse XML
                doc = etree.parse(StringIO.StringIO(content))

                ret = s.apply_query_criteria(query.criteria, doc)

                if not ret:
                    print "Query miss."
                    continue
                    
                print "Query hit."

            # Keep the 'latest' time up to date.
            if latest == None or then > latest:
                latest = then

            print "Adding %s" % fname

            # Create content block.
            cb = tm11.ContentBlock(tm11.ContentBinding(t.CB_STIX_XML_11), 
                                   content)

            # Append content block to list.
            cbs.append(cb)

        print "Done"

        # If there's no latest (i.e. there were no content blocks in scope,
        # then use current time.
        if latest == None:
            latest = now

        # Create poll response.
        resp = tm11.PollResponse(message_id=tm11.generate_message_id(),
                                 in_response_to=msg.message_id,
                                 collection_name=msg.collection_name,
                                 inclusive_end_timestamp_label=latest,
                                 content_blocks=cbs,
                                 more=False)

        # Send response
        s.respond(resp.to_xml())
        body = resp.to_xml()

    # Handling a TAXII DiscoveryRequest
    def handle_discovery_request(s, msg):
        
        # Create poll response.
        resp = tm11.DiscoveryResponse(message_id=tm11.generate_message_id(),
                                      in_response_to=msg.message_id)

        # Send response
        s.respond(resp.to_xml())
        body = resp.to_xml()

    # Handling a TAXII CollectionInformationRequest
    def handle_collection_information_request(s, msg):
        
        # Create poll response.
        msg_id=tm11.generate_message_id()
        resp = tm11.CollectionInformationResponse(message_id=msg_id,
                                      in_response_to=msg.message_id)

        # Send response
        s.respond(resp.to_xml())
        body = resp.to_xml()

    # Handling a TAXII CollectionInformationRequest
    def handle_manage_collection_subscription_request(s, msg):
        
        # Create poll response.
        msg_id=tm11.generate_message_id()
        resp = tm11.ManageCollectionSubscriptionResponse(message_id=msg_id,
                                                         collection_name=msg.collection_name,
                                                         in_response_to=
                                                         msg.message_id)

        # Send response
        s.respond(resp.to_xml())
        body = resp.to_xml()

    # HTTP head request
    def do_HEAD(s):
        s.send_response(200)
        s.send_header("Content-type", "text/html")
        s.end_headers()

    # HTTP POST request
    def do_POST(s):

        # Get the HTTP bdoy
        varLen = int(s.headers['Content-Length'])
        data = s.rfile.read(varLen)

        # Parse body as TAXII message.
        msg = tm11.get_message_from_xml(data)

        # If it's a poll request, handle it.
        if type(msg) == tm11.PollRequest:
            s.handle_poll_request(msg)
            return

        if type(msg) == tm11.InboxMessage:
            s.handle_inbox_message(msg)
            return

        if type(msg) == tm11.DiscoveryRequest:
            s.handle_discovery_request(msg)
            return

        if type(msg) == tm11.CollectionInformationRequest:
            s.handle_collection_information_request(msg)
            return

        if type(msg) == tm11.ManageCollectionSubscriptionRequest:
            s.handle_manage_collection_subscription_request(msg)
            return

        # Sorry, I only handle inbox and poll requests.

        resp = tm11.StatusMessage(message_id=tm11.generate_message_id(),
                                  in_response_to=msg.message_id,
                                  status_type=tm11.ST_FAILURE,
                                  message="Your request type not supported.")
        s.respond(resp.to_xml())

############################################################################
# Main body
############################################################################

# Parse command line arguments
p = argparse.ArgumentParser(description="Poll Client")
p.add_argument("--host", dest="host", default="localhost", 
               help="Host to start the HTTP service on. "
               "Defaults to localhost.")
p.add_argument("--port", dest="port", default="8080", 
               help="Port where the Poll Service is hosted. Defaults to "
               "8080.")
p.add_argument("--data_dir", dest="data_dir", default="data/", 
               help="Directory where the STIX data is stored. Defaults to "
               "'data'.")
args = p.parse_args()

# Create global variable?
data_dir = args.data_dir

# Construct HTTP server
server_class = BaseHTTPServer.HTTPServer
httpd = server_class((args.host, int(args.port)), TaxiiHandler)
print time.asctime(), "Server Starts - %s:%s" % (args.host, args.port)

# Serve indefinitely.
try:
    httpd.serve_forever()
except KeyboardInterrupt:
    pass
    httpd.server_close()
    print time.asctime(), "Server Stops - %s:%s" % (args.host, args.port)

